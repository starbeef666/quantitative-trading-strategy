### **交易系统最终版：V6.0 "极简核心版" - AI防错实现指南**

==============================================================================
**⚠️ AI实现警告：本文档包含AI容易误解的关键逻辑，请严格按照备注实现**
==============================================================================

#### **第1步：寻找猎物 (入场信号识别)**

**入场条件数学表达**：
*   连续3天收盘价不减：A≤B≤C
*   V型底：第一天前面的一天第0天的收盘价是过去n个交易日的最低点，包含自身 其中n≥20

**执行动作**：当且仅当以上所有条件全部满足时，在第3天以收盘价C执行买入。

🚨 **AI容易错误理解的地方1 - 索引和天数对应关系**：
- A、B、C分别是第1、2、3天的收盘价
- 第0天是第1天(A)的前一天
- 如果当前检查的索引是i，那么：
  * 第3天(C) = stock_data.iloc[i]['收盘']
  * 第2天(B) = stock_data.iloc[i-1]['收盘']  
  * 第1天(A) = stock_data.iloc[i-2]['收盘']
  * 第0天 = stock_data.iloc[i-3]['收盘']
- V型底检查：第0天的收盘价是过去n天(包含第0天自己)的最低点

🚨 **AI容易错误理解的地方2 - 边界条件检查**：
- 必须确保 i >= max(n天窗口, 3天上涨) + 额外安全边距
- 检查V型底时，window_start = (i-3) - n + 1，必须 >= 0
- 检查范围：for i in range(max(v_window, 3) + 5, len(data) - 2)



#### **第2步：设置防线 (固定止损策略)**

**止损线计算**：止损价 = 买入价C × (1 - 0.031)

**硬止损规则**：如果任意一天收盘价 < 止损价，立即清仓。此规则优先级最高，豁免期不可避免。

🚨 **AI容易错误理解的地方3 - 硬止损收益计算**：
- 硬止损时，total_pnl = remaining_shares × (exit_price / entry_price - 1)
- 注意：如果之前有分级减仓，remaining_shares < 1.0
- 硬止损后，remaining_shares = 0，交易结束
- ❌ 错误：不要在硬止损后继续计算其他收益

#### **第3步：管理交易 (分级减仓协议)**

**豁免期**：买入后第一天亏损，直接忽视，不执行任何操作。

🚨 **AI容易错误理解的地方4 - 豁免期基准价格**：
- 豁免期的比较基准是前一天收盘价，不是买入价
- 第一次出现 current_close < prev_close 时，设置 is_first_drop = False，但不减仓
- prev_close始终更新为当前收盘价：prev_close = current_close
- ❌ 错误：不要用买入价作为豁免期的比较基准

**分级减仓规则**（豁免期后）：
*   检查条件：每日收盘价与前一天收盘价比较
*   不减仓：收盘价 ≥ 前一天收盘价
*   减仓10%：收盘价 < 前一天收盘价，且跌幅在0%到2%之间
*   减仓20%：收盘价 < 前一天收盘价，且跌幅 > 2%

🚨 **AI容易错误理解的地方5 - 分级减仓收益计算（最关键！）**：
**正确的实现逻辑**：
```python
# 初始化
remaining_shares = 1.0      # 剩余份额（会减少）
total_pnl = 0.0            # 累计总收益
prev_close = entry_price    # 前一天收盘价初始化为买入价
is_first_drop = True        # 豁免期标志

# 每天检查
if current_close < prev_close:
    if is_first_drop:
        is_first_drop = False  # 豁免期，不减仓
    else:
        # 分级减仓
        drop_pct = (prev_close - current_close) / prev_close
        if 0 < drop_pct <= 0.02:
            sell_shares = remaining_shares × 0.10
        elif drop_pct > 0.02:
            sell_shares = remaining_shares × 0.20
        
        sell_pnl = sell_shares × (current_price / entry_price - 1)
        total_pnl += sell_pnl
        remaining_shares -= sell_shares

# 每天更新
prev_close = current_close

# 最终退出时（非硬止损）
remaining_pnl = remaining_shares × (exit_price / entry_price - 1)
total_pnl += remaining_pnl
```

❌ **错误的实现（导致之前14%胜率的罪魁祸首）**：
```python
# 错误1：只计算最终剩余仓位
pnl = remaining_shares × (exit_price / entry_price - 1)

# 错误2：忽略已卖出部分的收益
# 错误3：用复杂公式试图"修正"，如：
pnl = position × (exit_price / entry_price - 1) + (1 - position) - 1
```

🚨 **AI容易错误理解的地方6 - 前一天收盘价更新时机**：
- 每天都要更新：prev_close = current_close
- 豁免期和分级减仓的比较基准都是前一天收盘价
- 初始化：prev_close = entry_price（买入价作为第一个"前一天"）

**优先级顺序**：
1. 硬止损检查（最高优先级）
2. 豁免期（第一天亏损忽视）
3. 分级减仓（后续亏损按规则减仓）

==============================================================================
**📋 AI实现检查清单（避免再次出错）**
==============================================================================

✅ **入场逻辑检查**：
- [ ] 索引对应关系正确（第0天 = i-3, 第3天 = i）
- [ ] V型底窗口范围正确（包含第0天自己）
- [ ] 边界条件安全（足够的历史数据）
- [ ] 上影线计算正确（上影线 = 最高价 - max(开盘,收盘)）
- [ ] 成交量过滤正确（使用前c日平均，不包含当日）

✅ **收益计算检查**：
- [ ] 分级减仓时，每次卖出都单独计算收益并累加到total_pnl
- [ ] 硬止损时，只计算剩余仓位收益，不再继续
- [ ] 最终退出时，计算剩余仓位收益并累加

✅ **豁免期逻辑检查**：
- [ ] 豁免期基准是前一天收盘价，不是买入价
- [ ] 每天都要更新prev_close = current_close
- [ ] 第一次下跌后正确设置is_first_drop = False，但不减仓

✅ **分级减仓逻辑检查**：
- [ ] 减仓比例基于剩余仓位：sell_shares = remaining_shares × 比例
- [ ] 每次减仓后更新：remaining_shares -= sell_shares
- [ ] 比较基准是前一天收盘价（豁免期后）

✅ **数据结构检查**：
- [ ] remaining_shares（动态剩余份额）
- [ ] total_pnl（累计总收益）
- [ ] 过滤参数设置：a（上影线系数，≤1），b（成交量系数），c（成交量天数）

✅ **过滤条件检查**：
- [ ] 上影线过滤：upper_shadow ≤ a × entity_length
- [ ] 成交量过滤：current_volume ≤ b × avg_volume_c_days
- [ ] 参数合理性：a≤1, b>0, c≥1

==============================================================================
**🎯 预期结果范围（用于验证实现正确性）**
==============================================================================



**如果结果严重偏离上述范围，请检查**：
1. 分级减仓收益计算逻辑
2. 豁免期基准价格设置
3. 硬止损收益计算
4. 索引边界条件
5. 过滤条件实现（上影线和成交量计算）

==============================================================================
**💡 AI实现建议**
==============================================================================

1. **先实现简化版本**：只有硬止损，无分级减仓，验证基础逻辑
2. **逐步添加复杂性**：先加豁免期，再加分级减仓
3. **每步都验证结果**：确保胜率在合理范围内
4. **详细日志输出**：记录每次减仓的详细信息
5. **边界测试**：用少量股票先测试，确认逻辑正确

==============================================================================
**🔧 调试提示**
==============================================================================

如果胜率 < 35%：检查豁免期和分级减仓逻辑
如果胜率 > 50%：检查入场条件是否过松，或过滤条件过严
如果硬止损平均亏损 > -1%：检查分级减仓收益计算
如果期望收益 < 0%：检查收益计算的累加逻辑
如果信号过少：放宽过滤参数a、b，或减少c值
如果信号过多：收紧过滤参数a、b，或增加c值

记住：你的策略本身是优秀的，问题通常在实现细节！ 