### **交易系统终极版：V28.0 "最终版" - AI防错实现指南**

==============================================================================
**⚠️ AI实现警告：本文档是V27的最终升级版，融合沪深全市场AI模型。严格区分训练/测试，避免数据泄漏！性能必须对齐PRD核心目标：超过V6的1.08%期望收益，同时保持交易次数不低于V6的50%以确保流动性。**
==============================================================================

#### **核心理念**
- **信号源 (V6基石)**: 干净、无重复的V型底信号，确保趋势起始点。
- **AI引擎 (V27通用模型)**: 基于近10万条沪深历史信号训练的LightGBM模型，进行精准评分。
- **仓位管理**: 排名线性映射，确保高分信号获得更高仓位。
- **风控 (V6经典)**: 硬止损 + 豁免期 + 分级减仓，严格数学约束。

**PRD对齐**: 此策略目标期望收益 >1.08%，交易次数 ~25,000+ (基于历史数据)，胜率 ~58%。

---

#### **第1步：寻找高质量猎物 (V6核心信号源)**

**入场条件数学表达**:
*   连续4天收盘价不减: a ≤ b ≤ c ≤ d (a,b,c,d 为第1-4天收盘价)。
*   V型底: 第0天收盘价 = min{过去n天收盘价}，n≥20 (包含第0天)。

**执行动作**: 当所有条件满足时，识别为备选信号，在第4天以d买入。

🚨 **AI容易错误理解的地方1 - 信号唯一性与索引 (核心防重复)**:
- V型底确保信号在趋势起点，避免连续上涨中重复 (如V18错误)。
- 索引: 若当前i为第4天，则第0天=i-4，第1天=i-3。
- 公式: min_price_window = min(stock_data['收盘'][i-4 - n + 1 : i-4 + 1]) == stock_data['收盘'][i-4]。
- ❌ 错误: 窗口不含第0天，或n<20导致信号过多。

**核心代码实现 (完整伪代码，带防错注释)**:
```python
def check_entry_conditions(data, i, n=20):  # n>=20 as per mathematical constraint
    """检查V6入场信号，确保无重复和高起点。
    
    Args:
        data (pd.DataFrame): 股票历史数据，包含'收盘'列。
        i (int): 当前检查索引 (第4天)。
        n (int): V型底窗口大小，必须>=20。
    
    Returns:
        bool: True if signal is valid.
    """
    if i < 4 + n: return False  # 边界检查: 确保足够历史数据，避免索引错误
    
    # 连续4天不减: a <= b <= c <= d
    a = data['收盘'][i-3]  # 第1天
    b = data['收盘'][i-2]  # 第2天
    c = data['收盘'][i-1]  # 第3天
    d = data['收盘'][i]    # 第4天
    if not (a <= b <= c <= d): return False
    
    # V型底: 第0天是过去n天最低 (包含自身)
    zero_day = i - 4
    window_start = zero_day - n + 1
    if window_start < 0: return False  # 防错: 窗口不能越界
    window_prices = data['收盘'][window_start : zero_day + 1]
    if data['收盘'][zero_day] != window_prices.min(): return False
    
    return True  # 信号有效，仅在趋势起点生成
```

---

#### **第2步：通用AI大脑评估 (加载V27模型)**

**执行动作**:
1. 提取13个特征 (仅用信号当天及历史数据)。
2. 加载模型: joblib.load('v27_universal_model.pkl')。
3. 预测: 输出每个信号的评分 (预测收益)。

**特征列表 (数学定义示例)**:
- rsi_14 = 100 - 100 / (1 + (平均上涨14天 / 平均下跌14天))
- bottom_depth = (ma20 - 第0天收盘) / ma20 * 100 (n≥20)。
- ... (其余类似，详见V21文档)。

🚨 **AI容易错误理解的地方2 - 模型使用与防泄漏 (最大坑)**:
- 模型是成品，只能加载预测，不能重新训练。
- 训练时: X=历史特征, y=未来真实收益 (严格train/test split, test_size=0.2)。
- 禁止: 在预测中混入未来y，导致虚假高胜率 (>65%)。
- ❌ 错误: 无split，直接全数据训练 (如早期V21)。

**核心代码实现 (完整伪代码，带防错注释)**:
```python
import joblib
import pandas as pd

def predict_signal_quality(features_path, model_path='v27_universal_model.pkl'):
    """加载模型并预测信号质量，确保无数据泄漏。
    
    Args:
        features_path (str): 包含13特征的CSV路径 (仅历史数据)。
        model_path (str): 预训练模型路径。
    
    Returns:
        pd.Series: 每个信号的预测评分。
    """
    # 加载特征: 确保仅用信号当天及之前数据
    features = pd.read_csv(features_path)  # 假设列为['rsi_14', 'rsi_30', ..., 'bottom_depth']
    if features.shape[1] != 13: raise ValueError("特征必须 دقیق是13个，检查数据泄漏！")
    
    # 加载模型: 成品模型，禁止重新训练
    model = joblib.load(model_path)
    
    # 预测: 输入特征，输出评分
    scores = model.predict(features)
    return pd.Series(scores, index=features.index)  # 返回评分系列
```

---

#### **第3步：精英筛选与线性排名仓位管理**

**执行动作**:
1. 排序: 根据AI评分降序。
2. 筛选: 保留Top 40% (quantile(0.6))。
3. 排名: 在Top 40%内计算百分位 (0-100%)。
4. 映射: 仓位 = 2% + (rank_pct / 100) * (15% - 2%)。

**数学公式**:
- rank_pct = (信号评分 - min_top40) / (max_top40 - min_top40) * 100
- position = min_pos + (rank_pct / 100) * (max_pos - min_pos), min_pos=2, max_pos=15。

🚨 **AI容易错误理解的地方3 - 排名计算 (防流动性丢失)**:
- 只在Top 40%内排名，确保交易次数充足 (>25,000)。
- 线性映射防止极端: 最低2%避免全仓空，高于15%需人工审核。
- ❌ 错误: 用全信号排名，导致Top 40%过少，违背PRD流动性要求。

**核心代码实现 (完整伪代码，带防错注释)**:
```python
def assign_positions(signals_df, top_percentile=0.4, min_pos=2.0, max_pos=15.0):
    """筛选Top 40%并线性分配仓位，确保流动性。
    
    Args:
        signals_df (pd.DataFrame): 包含'评分'列的信号DataFrame。
        top_percentile (float): 筛选比例 (0.4 for Top 40%)。
        min_pos, max_pos (float): 仓位范围 (2% to 15%)。
    
    Returns:
        pd.DataFrame: 添加'position'列的精英信号。
    """
    if len(signals_df) < 100: raise ValueError("信号太少，检查流动性！")  # 防错: 确保充足交易
    
    # 筛选Top 40%: 根据评分quantile
    threshold = signals_df['评分'].quantile(1 - top_percentile)
    elite = signals_df[signals_df['评分'] >= threshold].copy()
    
    # 池内排名: 0-100%
    elite['rank_pct'] = elite['评分'].rank(pct=True) * 100
    
    # 线性映射: position = min + (pct / 100) * range
    pos_range = max_pos - min_pos
    elite['position'] = min_pos + (elite['rank_pct'] / 100) * pos_range
    
    return elite  # 返回带仓位的精英信号
```

---

#### **第4步：设置防线与管理交易 (V6经典风控)**

**规则数学表达**:
- 硬止损: if close < entry * (1 - 0.031), 清仓。
- 豁免期: 第一下跌日 (close < prev), 无操作。
- 分级减仓: if close < prev and not first_drop, drop_pct = (prev - close)/prev; if 0<drop_pct≤0.02 sell 10%, else 20%。

**收益计算公式**:
total_pnl += sell_shares * (close / entry - 1); remaining -= sell_shares。

🚨 **AI容易错误理解的地方4 - 收益累加与豁免 (V6大坑)**:
- 必须分段累加pnl，每次减仓单独计算。
- 豁免: 只设标志，不减仓; prev始终更新。
- ❌ 错误: 只算最终剩余 (导致胜率低至14%); 用entry作为豁免基准。

**核心代码实现 (完整伪代码，带防错注释)**:
```python
def simulate_trade(data, entry_idx, entry_price, holding_period=10):
    """模拟单笔交易的风控与收益计算，确保分段累加。
    
    Args:
        data (pd.DataFrame): 股票数据。
        entry_idx (int): 买入索引。
        entry_price (float): 买入价。
        holding_period (int): 最大持有天数。
    
    Returns:
        float: total_pnl (总收益率)。
    """
    remaining = 1.0
    total_pnl = 0.0
    prev = entry_price
    first_drop = True
    stop_loss = entry_price * (1 - 0.031)  # 硬止损线
    
    for day in range(entry_idx + 1, entry_idx + holding_period + 1):
        if day >= len(data): break  # 边界: 数据不足
        close = data['收盘'][day]
        
        # 硬止损: 最高优先
        if close < stop_loss:
            total_pnl += remaining * (close / entry_price - 1)
            return total_pnl  # 交易结束
        
        # 检查下跌
        if close < prev:
            if first_drop:
                first_drop = False  # 豁免，不减仓
            else:
                drop_pct = (prev - close) / prev
                sell_pct = 0.1 if drop_pct <= 0.02 else 0.2
                sell_shares = remaining * sell_pct
                total_pnl += sell_shares * (close / entry_price - 1)  # 分段累加
                remaining -= sell_shares
        
        prev = close  # 始终更新prev
    
    # 最终退出: 剩余仓位
    exit_price = data['收盘'][day] if 'close' in locals() else prev
    total_pnl += remaining * (exit_price / entry_price - 1)
    return total_pnl
```

---

==============================================================================
**📋 V28.0实现检查清单**
==============================================================================
- [ ] 信号: n≥20, 索引i-4正确。
- [ ] 模型: 加载v27.pkl, 无重新训练。
- [ ] 特征: 13个, 无未来数据。
- [ ] 排名: Top40%内线性映射2-15%。
- [ ] 风控: 止损0.031, 分段pnl累加。
- [ ] PRD: 交易>25k, 收益>1.08%。

==============================================================================
**🎯 V28.0预期结果范围 (基于诚实回测)**
==============================================================================
- **Top 20%**: 期望收益 ~2.25%, 胜率 ~58.11%, 交易 ~10,000+。
- **Top 40%**: 期望收益 ~1.71%, 胜率 ~46.96%, 交易 ~25,000+。
- **警告**: 若胜率>65%或收益>3%, 检查数据泄漏!

==============================================================================
**🔧 调试提示**
==============================================================================
- 胜率低: 检查豁免/减仓累加。
- 信号少: 放宽Top40%。
- 收益高: 验证split无泄漏。
- 始终日志: 记录每个减仓pnl。 